####### ----------------------------------------------------------#######
###           Data preparation and analysis code                   ###
####### ----------------------------------------------------------#######


# The purpose of this code is to allow the user to explore the evolving data sets.
#  There are two analysis branches, one for growth and the other for mortality .
#
#  Users set many output conditions in Global.R
#
#   In step 1 the conditions for the analysis are loaded.  Step 2 involves either
#   reconstructing the data from FIA SQL tables or loading existing data sets
#   and avoiding that time commitment.  Climate data and lat/longitude data are
#   loaded as well. Step 3 prepares the data for analysis and determines data 
#   conditions.  Step 4 is the analysis of data and generation of result tables.
#   Results are generated by species across the 3-state range, by state, and by
#   climate variable values (the initial-visit climate variable value and the 
#    change in climate variable value between visits).  Step 5 is the generation   
#    of figures. 
#
#     The code saves estimation output so that a Shiny dashboard can read and
#    display findings graphically and in ways that will not be done for the 
#    manuscript.
#




#### 1) Loading constants, libraries, and functions----------------------------

source("Global.R")
source(paste0(CODE.LOC, "Functions.R"))


#### 2) Base data prep --------------------------------------------------------
# These are the base data sets that will be transformed by the analysis types.



### ==> Load the tree/plot data ===================================================

# Working backwards: is the tree/plot data set ready to go? If so, let's unzip the CSV file and move ahead. 
#   If not, do the SQLite databases for CA/OR/WA need data extracted?  Those datasets are then processed by the 
# code to produce the tree/plot dataset.  
if(all(file.exists(file.path(DATA.LOC, "Distilled_Tree_Data.zip")), file.exists(file.path(DATA.LOC, "N_Plots.csv")))) {
  tree.plt.data <- read_csv(unzip(paste0(DATA.LOC, "Distilled_Tree_Data.zip"), "Distilled_Tree_Data.csv")) # This unzips the folder in the parent directory.
  plotN2 <- read_csv(file.path(DATA.LOC, "N_Plots.csv"), show_col_types = FALSE)
  file.remove("Distilled_Tree_Data.csv")
} else {
  ## Some info (harvest, fire deaths for trees) was absent in the range-shift analysis.  We need to introduce it here. 
  ##  The following code relies on downloaded and zipped SQLite FIA data from Oregon, Washington, and CA.  See the Global.R file:
  #    the zip files should be placed in the same folder, defined by SQL.LOC.  The following code unpacks, reduces, combines, and saves
  #   the PLOT, TREE, and COND files for each state as a zipped RDS file.  
  if (file.exists(paste0(DATA.LOC, "Addl_PlotTreeInfo.zip")) == FALSE) {
    source(paste0(CODE.LOC, "FIA_SQL_compile.R"))  # Data filtering for TREE occurs here as well. 
  }
  
  fia.tables <- read_rds(unzip(paste0(DATA.LOC, "Addl_PlotTreeInfo.zip"), "Addl_PlotTreeInfo.rds")) # This unzips the folder in the parent directory.
  
  # Deleting written RDS file (~200+ MB)
  if (file.exists("Addl_PlotTreeInfo.rds") == TRUE) {
    file.remove("Addl_PlotTreeInfo.rds")
  }
  
  # Now hopping over to run this code which will save the tree/plot zipped CSV file.
  source(paste0(CODE.LOC, "FIA_data_distillation.R"))
  
}

### ==> Load the climate data ===================================================
if (file.exists(paste0(DATA.LOC, "Climate_plot_results.rds")) == FALSE) {
  source(paste0(CODE.LOC, "Climate_Dat_Preparation.R"))  # Data filtering for TREE occurs here as well. 
}

climate.data <- read_rds(paste0(DATA.LOC, "Climate_plot_results.rds")) 

### ==> Load the latitude/longitude data ===================================================
# Bringing in Lat/Lon from earlier study. Needed to recreate State_Plot (above) for the join.  
latlon <- read_csv(paste0(DATA.LOC, "PlotLatLon.csv")) %>% select(-n)

# Selecting annual or summer climate variable, adding the variable State_Plot from the Groom/Vicente analysis 
# to enable joining of lat/lon info.
climate.use <- climate.data[[grep(CLIM.SUMMARY, names(climate.data))]] %>% 
  select (puid, pre_mean, difference) %>%
  rowwise() %>%
  mutate(plot = strsplit(puid, "_")[[1]][1], 
         state = strsplit(puid, "_")[[1]][2],
         State_Plot = as.numeric(paste0(plot, state))) %>%
  left_join(latlon, by = "State_Plot") %>%
  dplyr::select(-plot, -state, -State_Plot)

data.use <- left_join(tree.plt.data %>% dplyr::select(-LAT, -LON), climate.use, by = "puid")
dat.na <- data.use %>% filter(is.na(difference)) # 7 plots for which we don't have AET data
data.use <- anti_join(data.use, dat.na)


treedat.use <- data.use 

n_domain <- length(DOMAIN.LEVELS)

PlotDat <- treedat.use %>% dplyr::select(STATECD, puid, ESTN_UNIT, STRATUMCD, w) %>% 
  distinct() %>%
  mutate(stratum = as.numeric(paste0(STRATUMCD, 0, ESTN_UNIT, 0, STATECD))) 
#pd.check <- PlotDat %>% select(State_Plot) %>% distinct() # Yes, same number of rows


# Investigating weights.  Do we use area weights (Wh) or plot weights (n_h/N)?
# We do need to correct the number of plots per stratum so that the stratum-level mean 
# can be calculated.

plotN3 <- plotN2 %>% group_by(stratum) %>%
  summarize(n_h.plts = n())
  # Adding "n_h.plts" to data:
PlotDat <- left_join(PlotDat, plotN3, by = c("stratum"))

# tot.n <- sum(plotN3$n_h.plts)  # This is the total number of all plots in all strata. 
#  Not used in the analysis (at this point).

# Now just checking to see how Wh and n_h/N compare.
#  plt.use <- PlotDat %>% group_by(stratum, w) %>%
#  summarize(n.plts = n()) %>%
#  left_join(plotN3, by = "stratum") %>%
#  mutate(w.plts = n_h.plts / tot.n) 

#  It looks like the fit between Wh and n_h/N is pretty tightly linear.  
#   The fit is not quite 1:1.  It becomes noisy 
#ggplot(plt.use, aes(w.plts, w)) + geom_point() +     
#  geom_smooth(col = "orange", se = FALSE) +
#  geom_smooth(method = "lm", col = "blue") +
#    geom_abline(slope = 1, intercept = 0) + 
# xlim(0, 0.0025) + ylim(0, 0.0025)
  

#### 3) Specialized data prep --------------------------------------------------------
## First the data are summarized by species and climate variable (clim.mort.resp.fcn, 
#   clim.growth.resp.fcn).  Then the data are combined into arrays for 
#    analysis (parse.tree.clim.fcn).
tree.mort.dat <- map(sel.spp, clim.mort.resp.fcn, clim.var = CLIM.VAR.USE, treedat.sel = treedat.use, clim.dat = climate.use) 

# Create lists of tree growth and number of trees that grew in each plot
tree.grow.dat <- map(sel.spp, clim.growth.resp.fcn, clim.var = CLIM.VAR.USE, treedat.sel = treedat.use, clim.dat = climate.use) 


# Combining data into arrays and such, preparing for analysis.
arrays.mort <- parse.tree.clim.fcn(tree.mort.dat, clim.var = CLIM.VAR.USE, analysis.type = "mort", resp.dat = "died.out", tot.dat = "all.trees", selected.spp = SEL.SPP, clim.dat = climate.use)

arrays.grow <- parse.tree.clim.fcn(tree.grow.dat, clim.var = CLIM.VAR.USE, analysis.type = "grow", resp.dat = "growth.val", tot.dat = "growth.n.trees", selected.spp = SEL.SPP, clim.dat = climate.use)


#### 4) Analysis and plotting  --------------------------------------------------------


## Fire mortality: what proportion died from fire (and other causes)?  This info is only generated for pathway 1 and mortality.
if (CALC.FIREPROP == TRUE) {
  fire.frac.table.fcn(tablename = "Fire_Prop_mort.csv", tableloc = paste0(RESULTS1.LOC, "Mort_figs_", CLIM.VAR.USE, "/"), treedat = treedat.use, parseddat = arrays.mort)  
}

# Determining cause of death frequency for trees by species:
death.prop <- read_csv(paste0(RESULTS1.LOC, "Mort_figs_", CLIM.VAR.USE, "/Fire_Prop_mort.csv"), show_col_types = FALSE) %>%
  group_by(spp) %>%
  reframe(
    n = sum(tot),
    n.dead = sum(tot.dead),
    frac.fire = sum(tot.burn)/n.dead,
    frac.insect.disease = sum(tot.insect)/n.dead + sum(tot.disease)/n.dead,
    frac.animal = sum(tot.animal)/n.dead,
    frac.vegetation = sum(tot.vegetation)/n.dead,
    frac.unknown = sum(tot.unknown)/n.dead,
    frac.silviculture = sum(tot.silviculture)/n.dead,
  ) %>%
  mutate(frac.dead = n.dead/n)

#write_csv(death.prop, "death.prop.csv")


# If desired, the analysis will obtain mortality estimates for the selected species
#  by state and overall. These values can be used to evaluate species for inclusion in the
#  main analysis
if(RUN.STATES == TRUE) {
  source(paste0(CODE.LOC, "Overall_Mort_Est.R"))
}


# The remaining code breaks up the analyses by type (mortality, growth) and climate variable (AET).
# If ANALYSIS.PATHWAY is 2 then the process is run twice, once for each size class. 
#  The plotting functions are located at the end of the process, with each ANALYSIS.PATHWAY
#  having a distinct function.



tic() 
# For ANALYSIS.PATHWAY == 1, one climate variable, and 16 dedicated cores, the analysis takes about 8 minutes.
# With 6 domains and 23 species, 16 dedicated cores, 3.8 minutes

for(k in 1:length(ANALYSIS.TYPE)) {  # 1 = grow, 2 = mortality
  

    # Need climate names for files and axes.
    clim.names <- read_csv(paste0(DATA.LOC, "ClimateNames.csv"), show_col_types = FALSE) %>%
      filter(filename == CLIM.VAR.USE)

    var1 <- clim.names$values[grep("pre", clim.names$values)]
    var.delt <- clim.names$values[grep("d", clim.names$values)]
    

    var.label <- clim.names$label[clim.names$values == var1]
    #var.filename <- clim.names$filename[clim.names$values == var1]
    var.delt.label <- clim.names$label[clim.names$values == var.delt]
    
    # Obtaining the data to work with: Grabbing the list objects from above
    mort.grow.dat <- get(paste0("arrays.", ANALYSIS.TYPE[k])) 
    
    vals_dat <- mort.grow.dat$vals_dat
    all_dat <- mort.grow.dat$all_dat
    domain.array <- mort.grow.dat$domain.array
    state.array <- mort.grow.dat$state.array
    state.n <- mort.grow.dat$state.n
    domain.matrix <- mort.grow.dat$domain.matrix
    centroid.array <- mort.grow.dat$centroid.array
    domain.n <- mort.grow.dat$domain.n 
    quant.lims <- mort.grow.dat$quant.lims
    quant.lims.delta <- mort.grow.dat$quant.lims.delt
    
    
    
    ## First, adjusting the species list
    #spp.id <- paste0("X", spp.list)     # Can use SEL.SPP
    spp.list <- as.numeric(gsub("X", "", SEL.SPP))
    
    strat.num <- length(unique(vals_dat$stratum))

    n.spp <- length(SEL.SPP)
    
    
    # Strata for bootstrap resampling procedure
    strata <- unique(vals_dat$stratum)
    strata.num <- vals_dat %>% dplyr::select(stratum, puid) %>%
      ungroup() %>% 
      mutate(row.id = row_number())
    
    
    plan(multisession, workers = n.cores) # Setting up parallel computing. See Global.R for n.cores.
    
    
    ## Quantile estimates for mortality or growth, across select species.
    domain.index <- 1:n_domain
    
    
    ## Generating the bootstrap values: 
    bootstrap_results <- generate_bootstrap_array.fcn(
      vals.dat = vals_dat,
      all.dat = all_dat,
      domain.array = domain.array,
      domain.n = domain.n,
      selected.spp = SEL.SPP,
      n_iter = BS.N
    )

    
    # Finding and saving domain summaries
    domain.summaries <- domain.index %>% 
      map(\(d) domain.sum.fcn(bootstrap_results, d)) %>%
      do.call(rbind, .) %>%
      arrange(Species, Domain)
    
    saveRDS(list(bootstrap_results = bootstrap_results, domain.summaries = domain.summaries), file = paste0(save.loc.fcn(k), "Domain_Analysis_Output.RDS"))
    
    ## The code in this section is dedicated to preparing data files for plotting the differences in six-domain results.
    ## This process has two steps: first, the domain matrix pairs are subtracted from one another 
    #  using the domain.diff.fcn function.  Then, using the differenced matrices, the matrices
    #  are processed and prepared for figure creation.  Along the way the species' Latin names are
    #  prepped for inclusion.  
    if(n_domain == 6) {
      
    # Drier vs. Stable domains
    D.vec <- c("DL", "DM", "DH")
    S.vec <- c("SL", "SM", "SH")
    
    DvS <- bind_rows(map2(D.vec, S.vec, domain.diff.fcn, results.array = bootstrap_results)) %>%
      arrange(Species, Domain)
    
    # Drier, Low/Med/High comparisons
    D_LMH.vec1 <- c("DH", "DM", "DH")
    D_LMH.vec2 <- c("DL", "DL", "DM")
    
    D_LMH <- bind_rows(map2(D_LMH.vec1, D_LMH.vec2, domain.diff.fcn, results.array = bootstrap_results)) %>%
      arrange(Species, Domain)
    
    # Stable, Low/Med/High comparisons
    S_LMH.vec1 <- c("SH", "SM", "SH")
    S_LMH.vec2 <- c("SL", "SL", "SM")
    
    S_LMH <- bind_rows(map2(S_LMH.vec1, S_LMH.vec2, domain.diff.fcn, results.array = bootstrap_results)) %>%
      arrange(Species, Domain)
    
    spp.names.fig <- spp.names %>% select(SPCD, GENUS, SPECIES) %>% 
      mutate(Species = paste0("X", SPCD)) %>%
      select(-SPCD)
    
    
    DvS2 <- diff.fig.prep.fcn(DvS, diff.levels = c("DL - SL", "DM - SM", "DH - SH"))
    D_LMH2 <- diff.fig.prep.fcn(D_LMH, diff.levels = c("DH - DL", "DH - DM", "DM - DL"))
    S_LMH2 <- diff.fig.prep.fcn(S_LMH, diff.levels = c("SH - SL", "SH - SM", "SM - SL"))
    
    
    saveRDS(list(DvS = DvS, D_LMH = D_LMH, S_LMH = S_LMH, 
                 DvS2 = DvS2, D_LMH2 = D_LMH2, S_LMH2 = S_LMH2, 
                 spp.names.fig = spp.names.fig), 
            file = paste0(save.loc.fcn(k), "Processed_6Domain_Data.RDS"))
    
    
    }
    
  }   # end k 
  
toc()


# Plotting the multi-species panels

if(n_domain == 6) {
  for(k in 1:2){ # 1 = growth, 2 = mortality
    
plt.dat <- readRDS(paste0(save.loc.fcn(k), "Processed_6Domain_Data.RDS"))

DvS2 <- plt.dat$DvS2
D_LMH2 <- plt.dat$D_LMH2
S_LMH2 <- plt.dat$S_LMH2

xlab.use <- switch(k, "1" = "Annual Growth Rate (in2/yr)", "2" = "Annual Mortality Rate")
filename.use <- switch(k, "1" = "Growth_", "2" = "Mort_")

p1 <- diff.panel.fcn(DvS2, remove.y = FALSE, fig.title = "Dry vs. Stable", lab.right = FALSE)
p2 <- diff.panel.fcn(D_LMH2, remove.y = TRUE, fig.title = "Dry, High/Med/Low", lab.right = FALSE)
p3 <- diff.panel.fcn(S_LMH2, remove.y = TRUE, fig.title = "Stable, High/Med/Low", lab.right = TRUE)

grand.x.lab <- ggdraw() + draw_label(xlab.use, x = 0.6, y = 0.5) + theme_bw() + theme(rect = element_blank())

diff.plt <- plot_grid(p1, p2, p3, ncol = 3, rel_widths = c(0.9, 0.5, 0.5)) 

diff.plt2 <- plot_grid(diff.plt, grand.x.lab, 
                       ncol = 1, 
                       rel_heights = c(1, 0.03)) 

ggsave(paste0(save.loc.fcn(k), filename.use, "Panel_Plot.png"), plot = diff.plt2, device = "png", width = 10, height = 10, units = 'in')
}
}


  # Analysis Pathway 1: no subgroups of size or site class
for(k in 1:2){ # 1 = growth, 2 = mortality
  plt.dat <- readRDS(paste0(save.loc.fcn(k), "Domain_Analysis_Output.RDS"))
  plt.dat2 <- plt.dat$domain.summaries
  

  mort.grow.dat <- get(paste0("arrays.", ANALYSIS.TYPE[k])) 
  
  domain.matrix <- mort.grow.dat$domain.matrix
  domain.n <- mort.grow.dat$domain.n 
  quant.lims <- mort.grow.dat$quant.lims
  quant.lims.delta <- mort.grow.dat$quant.lims.delt
  
  
    
    # Plotting paired plots of mortality/growth by quantile and a scatterplot of plot distribution by quantiles.
    map(SEL.SPP, pair.plts.fcn, use.dat = plt.dat2, domain.matrix = domain.matrix,
                 quant.lims = quant.lims, domain.n = domain.n, k = k)
}










